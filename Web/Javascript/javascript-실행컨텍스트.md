# 06.Javascript : 실행 컨텍스트

**실행 컨텍스트**란? **자바스크립트 코드가 실행되는 환경**임.

실행가능한 코드는 전역코드, Eval 코드. 함수코드 이며, 실행에 필요한 여러가지 정보란 **변수, 함수선언, 변수 유효범위(Scope), this**가 있음 

### 실행 컨텍스트(문맥)란?

자바스크립트 코드를 실행할때 필요한 정보들을 저장하고 제공하는 환경, 즉 **스코프의 정보를 담은 환경**을 의미 

현재 실행되고 있는 컨텍스트에서 이 컨텍스트와 관련이 없는 코드가 생성이 되면 새로운 컨텍스트가 생성되어 제어권을 가져감. 

그리고 생선된 컨텍스트들은 실행 컨텍스트 스택 안에 쌓이게 됨. 각각의 컨텍스트는 실행이 종료된 이후에 소멸됨

### 실행 컨텍스트의 구성요소

실행 컨텍스트는 Lexical Environment와 Variable Environment라는 두가지 컴포넌트로 구성이 됨.

### Environment Records와 스코프 체인

ER은 렉시컬 스코프를 기반으로 특정 변수와 함수에 대한 식별자의 연결함. 코드가 실행되면 변수나 함수에 대한 식별자를 선언하고 코드가 한줄 한줄 실행 될때마다 선언된 식별자에 값을 할당할 수 있도록 바인딩

**모든 ER에는 OuterEnv필드가 있으며 이 필드는 상위 렉시컬 스코프에 대한 ER을 참조함** 

스코프 체인(lexical nesting structure)의 원리가 바로 OuterEnv의 필드를 통해서 상위 스코프의 ER에 접근하여 식별자를 찾는것임. 

그리고 식별자를 찾을때까지 반복되며 찾는 즉시 중단됨 

### 다양한 Environment Records

environment records에는 세가지의 하위 ER이 있음 

1. **declarative Environment Recod**
    
    변수, 상수, 클래스, 모듈 또는 함수선언 등 렉시컬 스코프에 선언된 식별자들을 바인딩
    
    **module Environment Record**: 모듈의 외부 스코프를 나타내는 정보를 추가적으로 바인딩. 다른 ER에 존재하는 식별자에 간접적으로 접근 할 수있는 가져오기(import) 바인딩 제공
    
    funtion Environment Record: 함수 내 최상위 위치 (top-level)에 선언한 식별자를 바인딩. 
    
2. **object Environment Record** 
    
    binding object라는 객체의 프로퍼티들을 식별자로 바인딩 binding object 객체의 프로퍼티들은 사이드이펙트에 의해 동적으로 변경될수 있음 
    

1. **global Environment Record**
    
    최상위 전역 스코프에서 선언된 식별자와 전역 객체에 대한 바인딩. **declarative와 object를 합성한 형태** 
    
    binding object는 우리가 window로 접근하는 전역 객체. 그 외의 나머지 식별자들에 대한 바인딩은 declarative 는 우리가 전역 변수라고 부름. 
    

### 실행 컨텍스트의 생성 과정

1. **전역컨텍스트 생성과 바인딩** 
    1. 전역 컨텍스트가 생성되면 global ER이 생성됨. global ER은 this바인딩과 OuterEnv필드만 설정된상태 이며, 식별자에 대한 어떠한 바인딩도 이뤄지지 않음.
    2. 이후 코드가 실행되며 Global ER에 함수 선언문을 바인딩함 
2. **함수 실행 컨텍스트 생성과 바인딩** 
    1. 함수를 호출하면 새로운 함수 실행 컨텍스트가 되어 제어권을 가져감. 
    2. 함수 ER은 OuterEnv로 상위 Global ER을 참조하고있음. 이외에 어떤 식별자에 대한 바인딩도 없음 
    3. 이후 식별자들과 this가 순차적으로 바인딩됨. 엄격모드라면 this는 undefined, 아니라면 전역객체로
    
    함수선언으로 선언된것은 함수로 바인딩됨. **실행컨텍스트의 식별자 바인딩 과정이 바로 호이스팅의 원리** 
    
    함수 선언문은 초기화에서 더 나아가 값의 할당까지 이루어짐. 이들은 바인딩과 동시에 초기화 되기때문에 컨텍스트 어디에서도 접근이 가능함 
    
3. **함수 표현식의 실행컨텍스트 생성과 바인딩**
    1. 함수 표현식도 순차적으로 this와 바인딩이 된다. 
    2. 그러나 함수 선언과는 다르게 식별자가 바인딩은 되었지만 초기화가 되지 않았기 때문에 접근할수 없는 상태가 된다.(uninitilized)
    3. 선언문을 만나기 전까지는 식별자는 초기화 되지 않음 
    4. 선언문을 만나면 식별자가 초기화 되며 값이 할당됨 
    5. 즉, 위의 과정이 실행 컨텍스트에서 let 과 const의 Temporal Dead Zone(TDZ)구간이 생성되는 과정임.
4. **console.log()메서드 실행** 
    1. 스코프 체인이라고 불리었던 lexical nesting structure을 통해서 검색하여 console.log()함수 실행