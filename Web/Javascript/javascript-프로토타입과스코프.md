# 05.Javascript : 프로토타입과 스코프

조금 더 공부가 필요한 부분

---

## 프로토 타입

자바스크립트는 **프로토타입을 기반**으로 객체 지향의 상속개념을 구현. **프로토타입의 참조 링크를 가지고 있으며, 링크를 통해 프로토타입으로부터 프로퍼티나 메서드를 상속**받을수 있음. 

프로토 타입은 **참조 링크 형태로 저장**되기 때문에 **동일한 프로토 타입을 상속받은 객체는 모두 같은 프로퍼티와 메서드를 공유** 

### 프로토타입 체인

프로토타입 체인은 상위 프로토타입과 연쇄적으로 연결된 구조를 의미.

```jsx
const obj = {
	name: 'javascript'
}

console.log(obj.toString()) // '[object object]'
```

프로퍼티나 메서드에 접근하기 위해 이 연결 구조를 따라 차례대로 검색하는것을 프로토타입 체이닝이라고 함. (상위 객체부터 차례대로)

### 최상위 프로토타입

sObject.prototype은 프로토타입 체인의 최상위에 있는 프로토타입임

---

## 스코프

**스코프는 변수나 매개변수에 접근할 수 있는 범위를 결정**하는것. 함수와 블록단위의 스코프로 나눌수 있으며 함수나 블록의 선언위치에 따라 중첩된 스코프가 정의될수있다.

### 함수스코프

선언된 **함수 단위로 생성되는 스코프**. 함수 스코프 안에 선언된 함수나 변수는 모두 함수 스코프 안에 포함 

```jsx
function foo(){
	var a = 1;
	function bar(b) {
		console.log(a,b) // 1,2 
	}	
	bar(2)
}
foo()
```

함수가 선언되며 함수 스코프 안에서는 블록을 무시하고 함수의 몸체안에서 접근이 가능함. 

그러나 이러한 방법은 외부에서 조건문 안의 변수에 접근하는 경우는 대부분 업슬 뿐더러 직관적이지 않기 때문에 실수를 줄이기 위해서 블록스코프를 선언하는것이 좋음 

### 블록스코프와 let, const

블록스코프에서는 변수의 유효 범위를 블록({})단위로 제한하여 사용할수 있음. 

let const를 사용하여 선언된 변수는 블록 스코프를 따른다

```jsx
function foo(){
	if (true) {
		const a = 1;
	}
	console.log(a) // Uncaught ReferenceError
}
foo()
```

const로 선언한 변수는 블록 안에서만 유효하며, 블록을 벗어나서는 접근할수없다. 변수가 블록스코프를 갖도록 선언하는것이 직관적이며 버그를 줄일수 있음 

### 렉시컬 스코프

프로그래밍언어의 대부분은 동적스코프와 렉시컬 스코프 두가지 방식으로 동작.

**동적스코프**란 **런타임 중 함수의 호출의 의해 결정**되는것, **렉시컬스코프**란 **변수나 함수를 어디에 작성하였는가에 기초해여 결정** 

**스코프는 함수를 어디서 작성을 했는가에 따라 명확하게 경계를 가지며, 렉시컬 스코프의 규칙에 따라 경계 결정** 

중첩된 스코프 내에서 코드가 실행된 경우 **가장 안쪽의 스코프 부터 하여서 상위스코프로 올라가며** 원하는 대상을 검색함. 그리고 대상을 찾는 즉시 검색을 중단함 

안쪽으로 부터 상위로 검색하며 올라가기 때문에 **상위 스코프에서는 안쪽 스코프의 변수나 함수에 접근 할수없다.**

이러한 **스코프들의 연결관계**를 스코프 체인이라고 하며, **스코프 체인을 따라서 검색하는 과정**을 **스코프 체이닝**이라고함 

---

# 호이스팅

스코프안에 변수를 선언하였을때 호이스팅이라는 동작이 발생됨. **호이스팅**은 **선언문이 스코프 내의 가장 최상단으로 끌어올려지는것**을 의미 

- 자바스크립트의 변수 세가지 단계 나누어 생성
    1. **선언**: 스코프에 변수를 선언함
    2. **초기화**: 변수의 값에 undefined로 초기화, **실제로 변수에 접근 가능한 단계**임.
    3. **할당**: 할당문을 만나면 변수에 실제 값을 할당함.

var 키워드로 선언한 변수는 선언+초기화 단계를 한꺼번에 실행. 그리고 최상단으로 끌어올려져 실행됨. 

따라서 선언하기전에 변수에 접근하여도 초기화가 되어 접근이 가능한것.

전역 스코프가 아닌 함수 내에 선언된 변수는 함수 스코프 안에서 호이스팅이 발생함.

### let과 const

선언 단계는 스코프의 최상단으로 끌어올려져 실행되지만, **초기화 단계는 선언문을 만나야 실행됨.** 

초기화 단계 이전에 변수에 접근하면 ReferenceError발생. 

선언단계가 실행되는 스코프의 최상단부터 초기화 단계를 실행하는 선언문이 나오기 전까지 변수에 접근 불가. 이 부분을 Temporal Dead Zone(TDZ)라고 부름 

### 함수 선언문의 호이스팅

함수선언문에서는 함수선언, 초기화, 할당 세가지 단계가 모두 동시에 스코프 최상단에서 실행됨. 어느 위치에서는 함수 호출이 가능함.

---

# 클로저

클로저는 함수의 렉시컬 스코프를 기억하여 **함수가 렉시컬 스코프를 벗어난 외부 스코프에서 실행될때에도 자신의 렉시컬 스코프에 접근할 수 있게 해주는것**.

```jsx
function foo(){
	var a = 1;
	function bar() {
		console.log(a) // 1
	}
	return bar;
}
const baz = foo()
baz(); //1
```

**코드의 실행순서** 

1. bar()함수는 렉시컬 스코프 체인을 통해 foo()함수의 스코프를 기억한다.
2. bar()함수를 전역 변수 baz에 할당
3. 전역 변수 baz를 사용하여 bar()를 호출함 
4. bar() 함수는 자신의 스코프에서 변수 a를 찾음 
5. 자신의 스코프에서 찾을수 없기에 스코프 체인을 통해 foo()에서 찾음
6. foo()함수의 스코프에서 변수 a를 찾아 출력 

**클로저를 사용하면 외부에서도 얼마든지 원래의 렉시컬 스코프에 접근가능** 

---

# 모듈

모듈은 내부 구현에 대한 캡슐화 역할을 함. 각각의 모듈은 애플리케이션을 구성하는 단위가 되며, 모듈을 재사용하여 불필요한 코드 줄임

### 자바스크립트 모듈의 진화

ES2015이전에는 모듈이라는 개념 존재하지 않음. ES2015이후로 모듈 문법이 등장. 

ES모듈은 각 파일을 독립적인 스코프로 처리함. 내보내기를 한 식별자가 아니라면 해당 모듈 내에서만 접근 가능하고 외부에서는 접근 불가능 하다. 

하지만 모듈은 레거시 브라우저에서는 지원하지 않아서 webpack, babel을 사용하여 이용함. 

### export, import

모듈안에서 선언한 식별자를 다른 모듈에서 접근하고 싶다면 export를 붙여줘야함. 이들은 모들의 최상단에 위치해야함.

**export 키워드를 이용해서 개별 식별자를 내보내느것을 named exports 라고 부름** 

다른 모듈에서 내보낸 식별자를 가져오기 위해서는 import키워드를 사용해야한다. 반드시 최상단에 위치해야함.

### default export

**default export**는 named exports와 다르게 **모듈에서 하나만 정의**할수있음. 중괄호 사용 가능

### 식별자 충돌 피하기

여러 모듈에서 식별자를 가져오는 경우 이름이 충돌할수 있음. 이럴경우에 **as 키워드를 사용하여 식별자의 이름 변경 가능** 

정의한 모듈을 브라우저 환경에서 사용하기 위해서는? script 태그에 type=’module’속성을 설정하여야 한다. 

```html
<!DOCTYPE html>
<html>
	<body>
		<script type ='modules' src='a.mjs'></script>
		<script type ='modules' src='b.mjs'></script>
	</body>
</html>
```

mjs는 자바스크립트 파일이 모듈임을 명시하기 위해서 사용